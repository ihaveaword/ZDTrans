# 发布流程常见问题解答

## 问题 1: 为什么这次没有用 build.sh 脚本？

### 两种打包方式对比

#### 方式 1: build.sh (一键打包)
```bash
source .venv/bin/activate
./build.sh
```

**特点**:
- ✅ 简单方便，一键执行
- ✅ 自动清理旧文件
- ✅ 适合快速打包测试
- ❌ 每次都重新生成 .spec 文件
- ❌ 无法保留优化配置

**build.sh 做了什么**:
```bash
1. 清理旧文件 (rm -rf build dist *.spec)
2. 执行 PyInstaller 命令行打包
3. 使用默认配置
```

#### 方式 2: pyinstaller zdtrans.spec (推荐)
```bash
source .venv/bin/activate
pyinstaller zdtrans.spec
```

**特点**:
- ✅ 可以精细控制打包配置
- ✅ 保留优化设置（excludes, optimize 等）
- ✅ 适合正式发布
- ✅ 配置可复用和版本管理
- ❌ 需要手动维护 .spec 文件

**这次为什么用 .spec 方式**:

1. **保留优化配置**
   ```python
   # zdtrans.spec 中的优化
   excludes=[
       'matplotlib', 'numpy', 'pandas',  # 减小体积
       'PySide6.QtNetwork', 'PySide6.QtOpenGL',  # 排除不用的 Qt 模块
       ...
   ]
   optimize=2,  # 最高优化级别
   strip=True,  # 移除调试信息
   ```

2. **可重复构建**
   - .spec 文件在 Git 中版本管理
   - 每次发布使用相同配置
   - 结果一致可预测

3. **更小的包体积**
   - build.sh: 约 39MB
   - .spec 优化: 38MB (-2.6%)

### 什么时候用哪种方式？

**开发阶段** - 使用 build.sh
```bash
./build.sh  # 快速测试打包是否成功
```

**正式发布** - 使用 .spec
```bash
pyinstaller zdtrans.spec  # 使用优化配置
```

**首次打包** - 生成 .spec
```bash
./build.sh  # 生成基础 .spec
# 然后编辑 zdtrans.spec 添加优化
# 以后都用 pyinstaller zdtrans.spec
```

---

## 问题 2: 版本号规则 (为什么是 v1.2.3 而不是 v1.0.1)

### 语义化版本 (Semantic Versioning)

版本号格式: **主版本.次版本.修订版本** (MAJOR.MINOR.PATCH)

```
v1.2.3
  │ │ │
  │ │ └─ PATCH (修订版本): 3
  │ └─── MINOR (次版本): 2
  └───── MAJOR (主版本): 1
```

### 版本号递增规则

#### PATCH (修订版本) - 第三位数字
**何时递增**: 向后兼容的 Bug 修复

**示例**:
- v1.0.0 → v1.0.1: 修复日间模式字体颜色 bug
- v1.0.1 → v1.0.2: 修复设置保存错误
- v1.0.2 → v1.0.3: 修复快捷键冲突

**特征**:
- ✅ 只修复问题
- ✅ 不添加新功能
- ✅ 向后完全兼容
- ✅ 用户可放心更新

#### MINOR (次版本) - 第二位数字
**何时递增**: 添加新功能，但向后兼容

**示例**:
- v1.0.0 → v1.1.0: 添加夜色模式
- v1.1.0 → v1.2.0: 添加自定义学科领域
- v1.2.0 → v1.3.0: 添加翻译历史功能

**特征**:
- ✅ 新增功能
- ✅ 向后兼容
- ✅ 旧配置仍然可用
- ✅ 不破坏现有功能

#### MAJOR (主版本) - 第一位数字
**何时递增**: 重大更新，可能不兼容旧版本

**示例**:
- v1.9.9 → v2.0.0: 完全重写 UI 框架
- v2.9.9 → v3.0.0: API 配置格式改变

**特征**:
- ⚠️ 可能破坏兼容性
- ⚠️ 旧配置可能不可用
- ⚠️ 需要用户重新配置
- ⚠️ 重大架构变更

### 本次版本分析: v1.0.0 → v1.2.3

**为什么不是 v1.0.1？**

我们添加了 **3 个重要新功能**：
1. 🌙 夜色模式 (新功能)
2. 🎓 自定义学科领域 (新功能)
3. 📝 界面优化 (新功能 + Bug修复)

**版本跳跃过程**:

```
v1.0.0 (首个稳定版)
   ↓
v1.1.0 (添加夜色模式)
   ↓
v1.2.0 (添加自定义学科领域)
   ↓
v1.2.1 (修复日间模式颜色 bug)
   ↓
v1.2.2 (设置窗口滚动优化)
   ↓
v1.2.3 (关键词输入框优化)
```

**实际上我们一次性完成了所有这些**，所以直接跳到 v1.2.3

**更合理的做法** (如果分批发布):
- v1.0.0 → v1.1.0: 夜色模式
- v1.1.0 → v1.2.0: 自定义领域
- v1.2.0 → v1.2.1: 日间模式 bug 修复
- v1.2.1 → v1.2.2: 滚动条优化
- v1.2.2 → v1.2.3: 关键词优化

### 版本号选择指南

#### 场景 1: 只修复 Bug
```
v1.0.0 → v1.0.1  ✅ 正确
原因: 只修复，不添加功能
```

#### 场景 2: 添加小功能
```
v1.0.0 → v1.1.0  ✅ 正确
v1.0.0 → v1.0.1  ❌ 错误 (太保守)
原因: 有新功能，应该递增 MINOR
```

#### 场景 3: 添加多个功能
```
v1.0.0 → v1.1.0  ✅ 可以 (保守)
v1.0.0 → v1.2.0  ✅ 可以 (如果功能很多)
v1.0.0 → v2.0.0  ❌ 除非不兼容
```

#### 场景 4: 重大重构
```
v1.9.0 → v2.0.0  ✅ 正确
原因: 重大变更，可能不兼容
```

### 本项目的版本历史

```
v1.0.0 (2024-10-29)
├── 基础翻译功能
├── 全局快捷键
├── 系统托盘
└── 9个预设学科领域

v1.2.3 (2025-10-31)  ← 当前版本
├── 🌙 夜色模式 (MINOR +1)
├── 🎓 自定义学科领域 (MINOR +1)
├── 📝 界面优化
│   ├── 滚动条 (PATCH +1)
│   ├── 颜色修复 (PATCH +1)
│   └── 输入框优化 (PATCH +1)
└── 💻 代码重构
```

### 下一个版本应该是什么？

**如果只修复 bug**:
```
v1.2.3 → v1.2.4
```

**如果添加新功能**:
```
v1.2.3 → v1.3.0
示例: 添加翻译历史记录
```

**如果重大更新**:
```
v1.2.3 → v2.0.0
示例: 完全重写 UI，改用 Electron
```

### 版本号最佳实践

1. **遵循语义化版本**
   - 让用户一看就知道更新内容
   - 便于自动化工具处理

2. **从 v1.0.0 开始正式版**
   - v0.x.x = 开发版
   - v1.0.0 = 第一个稳定版

3. **清楚标注不兼容变更**
   - MAJOR 版本变更要在文档中明确说明
   - 提供迁移指南

4. **保持一致性**
   - 制定版本策略并坚持
   - 写在文档中

### 总结

| 更新类型 | 示例 | 版本变化 |
|---------|------|---------|
| Bug 修复 | 修复颜色显示 | v1.0.0 → v1.0.1 |
| 新功能 | 夜色模式 | v1.0.0 → v1.1.0 |
| 多个新功能 | 本次发布 | v1.0.0 → v1.2.3 |
| 不兼容更新 | 重写 UI | v1.9.9 → v2.0.0 |

**本次选择 v1.2.3 是合理的**，因为：
- ✅ 有 2 个重要新功能 (MINOR +2)
- ✅ 有 3 个优化/修复 (PATCH +3)
- ✅ 向后兼容 (不需要 MAJOR +1)

---

## 推荐资源

- [语义化版本规范](https://semver.org/lang/zh-CN/)
- [PyInstaller 文档](https://pyinstaller.org/)
- [Git 标签最佳实践](https://git-scm.com/book/zh/v2)

